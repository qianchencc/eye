#!/bin/bash

# =================é…ç½®ä¸è·¯å¾„å®šä¹‰ (XDGå‡†åˆ™)=================
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/eye"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/eye"
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/eye"

CONFIG_FILE="$CONFIG_DIR/config"
CUSTOM_SOUNDS_MAP="$CONFIG_DIR/custom_sounds.map"
EYE_LOG="$STATE_DIR/last_notified"
PID_FILE="$STATE_DIR/daemon.pid"
PAUSE_FILE="$STATE_DIR/pause_until"
PAUSE_START_FILE="$STATE_DIR/pause_start"
STOP_FILE="$STATE_DIR/stop_time"

# Systemd user service path
SYSTEMD_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user"
SERVICE_FILE="$SYSTEMD_DIR/eye.service"

# ç¡®ä¿ç›®å½•å­˜åœ¨
mkdir -p "$CONFIG_DIR" "$DATA_DIR/sounds" "$STATE_DIR"

# é»˜è®¤é…ç½®
DEFAULT_REST_GAP=1200
DEFAULT_LOOK_AWAY=20
DEFAULT_SOUND_START="default"
DEFAULT_SOUND_END="complete"
DEFAULT_SOUND_SWITCH="on"
DEFAULT_LANGUAGE="en"

# =================å¤šè¯­è¨€æ”¯æŒ (Centralized Messages)=================
_init_messages() {
    if [[ "$LANGUAGE" == "zh" ]] || [[ "$LANGUAGE" == "Chinese" ]]; then
        LANG_MODE="zh"
    elif [[ "$LANGUAGE" == "en" ]] || [[ "$LANGUAGE" == "English" ]]; then
        LANG_MODE="en"
    elif [[ -z "$LANGUAGE" ]]; then
        if [[ "$LANG" == zh* ]]; then
            LANG_MODE="zh"
        else
            LANG_MODE="en"
        fi
    else
        LANG_MODE="en"
    fi

    if [ "$LANG_MODE" == "zh" ]; then
        MSG_USAGE_HEADER="ç”¨æ³•: eye <command> [args]"
        MSG_USAGE_CORE="æ ¸å¿ƒå‘½ä»¤:"
        MSG_USAGE_CMD_START="  start            å¯åŠ¨æŠ¤çœ¼åå°è¿›ç¨‹"
        MSG_USAGE_CMD_STOP="  stop             åœæ­¢æŠ¤çœ¼è¿›ç¨‹ (ä¼˜é›…é€€å‡º)"
        MSG_USAGE_CMD_KILL="  kill             å¼ºåˆ¶æ€æ­»æ‰€æœ‰è¿›ç¨‹å¹¶é‡ç½®çŠ¶æ€ (ç›¸å½“äºå½»åº•æ¸…é™¤)"
        MSG_USAGE_CMD_PAUSE="  pause <time>     æš‚åœæŠ¤çœ¼æ¨¡å¼æŒ‡å®šæ—¶é•¿ (ä¾‹å¦‚: 1h, 30m, 1h30m)"
        MSG_USAGE_CMD_RESUME="  resume           å–æ¶ˆæš‚åœï¼Œç«‹å³æ¢å¤"
        MSG_USAGE_CMD_PASS="  pass <time>      è·³è¿‡æŒ‡å®šç­‰å¾…æ—¶é—´ (è®©ä¸‹æ¬¡ä¼‘æ¯æå‰åˆ°æ¥)"
        MSG_USAGE_CMD_STATUS="  status           æŸ¥çœ‹å½“å‰çŠ¶æ€"
        MSG_USAGE_CMD_NOW="  now [--reset]    ç«‹å³æ‰§è¡Œä¸€æ¬¡æŠ¤çœ¼æé†’ (--reset é‡ç½®è®¡æ—¶å™¨)"
        MSG_USAGE_CMD_SET="  set <gap> <look> è®¾ç½®æ—¶é—´é—´éš”å’Œè¿œçœºæ—¶é•¿ (æ”¯æŒå•ä½ s, m, h)\n                   ä¾‹å¦‚: eye set 20m 20s"
        MSG_USAGE_CMD_LANG="  language <lang>  è®¾ç½®è¯­è¨€ (English/Chinese)"
        MSG_USAGE_CMD_AUTOSTART="  autostart [on|off] ç®¡ç†å¼€æœºè‡ªå¯ (systemd)"
        MSG_USAGE_AUDIO="éŸ³é¢‘ç®¡ç† (eye sound ...):"
        MSG_USAGE_CMD_SOUND_LIST="  sound list              åˆ—å‡ºæ‰€æœ‰å¯ç”¨éŸ³æ•ˆ"
        MSG_USAGE_CMD_SOUND_PLAY="  sound play <tag>        è¯•å¬æŒ‡å®šæ ‡ç­¾çš„éŸ³æ•ˆ"
        MSG_USAGE_CMD_SOUND_SET="  sound set <start> <end> è®¾ç½®å¼€å§‹å’Œç»“æŸçš„æç¤ºéŸ³"
        MSG_USAGE_CMD_SOUND_ADD="  sound add <tag> <path>  æ·»åŠ è‡ªå®šä¹‰éŸ³é¢‘æ–‡ä»¶"
        MSG_USAGE_CMD_SOUND_RM="  sound rm  <tag>         åˆ é™¤è‡ªå®šä¹‰éŸ³æ•ˆ"
        MSG_USAGE_CMD_SOUND_SWITCH="  sound on|off            å…¨å±€å¼€å¯æˆ–å…³é—­å£°éŸ³"
        
        MSG_START_ALREADY_RUNNING="âš ï¸  æŠ¤çœ¼æ¨¡å¼å·²åœ¨è¿è¡Œä¸­ (PID: %s)"
        MSG_START_STARTED="âœ… æŠ¤çœ¼æ¨¡å¼å·²å¯åŠ¨"
        MSG_STOP_STOPPED="ğŸ›‘ å·²åœæ­¢"
        MSG_STOP_NOT_RUNNING="âš ï¸  æœªè¿è¡Œ"
        MSG_KILL_DONE="âœ… å·²å¼ºåˆ¶æ¸…é™¤æ‰€æœ‰è¿›ç¨‹å¹¶é‡ç½®çŠ¶æ€"
        MSG_PAUSE_SPECIFY_DURATION="âŒ è¯·æŒ‡å®šæ—¶é•¿ (å¦‚ 1h, 30m)"
        MSG_PAUSE_PAUSED="â¸ï¸  æŠ¤çœ¼æ¨¡å¼æš‚åœ %s (ç›´åˆ° %s)"
        MSG_PAUSE_ERROR_FORMAT="âŒ æ ¼å¼é”™è¯¯ã€‚ç¤ºä¾‹: 1h, 30m, 10s"
        MSG_RESUME_RESUMED="â–¶ï¸  æš‚åœå·²å–æ¶ˆï¼Œæ¢å¤è¿è¡Œ"
        MSG_RESUME_NOT_PAUSED="âš ï¸  å½“å‰æœªå¤„äºæš‚åœçŠ¶æ€"
        MSG_PASS_ERROR="âŒ è¯·æŒ‡å®šæ—¶é—´ (å¦‚ 10m)"
        MSG_PASS_SKIPPED="â© å·²è·³è¿‡ %s (ä¼‘æ¯å°†æå‰åˆ°æ¥)"
        MSG_PASS_TRIGGERED="âš¡ï¸ æ—¶é—´ç´¯ç§¯å·²è¶…é™ï¼Œç«‹å³è§¦å‘ä¼‘æ¯ï¼"
        MSG_NOW_MANUAL_RESET="âœ… å·²è§¦å‘æ‰‹åŠ¨æ”¾æ¾ï¼Œè®¡æ—¶å™¨å·²é‡ç½®ã€‚"
        MSG_NOW_MANUAL_TRIGGERED="âœ… å·²è§¦å‘æ‰‹åŠ¨æ”¾æ¾ã€‚"
        MSG_NOW_MANUAL_NO_RESET="ğŸ”” å•æ¬¡æ”¾æ¾æ‰§è¡Œå®Œæ¯•ã€‚(æ³¨æ„ï¼šæŠ¤çœ¼æœåŠ¡å½“å‰å¤„äºå…³é—­çŠ¶æ€)"
        MSG_NOW_TRIGGERING="ğŸ”„ æ­£åœ¨è§¦å‘è¿œçœº..."
        MSG_STATUS_RUNNING="ğŸŸ¢ è¿è¡Œä¸­ | PID: %s"
        MSG_STATUS_PAUSED_REMAINING="â¸ï¸  [å·²æš‚åœ] å‰©ä½™: %s (ç›´åˆ° %s)"
        MSG_STATUS_STOPPED="ğŸ”´ æœåŠ¡å·²åœæ­¢ (Stopped)"
        MSG_STATUS_KILLED="ğŸ”´ æœåŠ¡æœªè¿è¡Œ (Not Running)"
        MSG_STATUS_STOPPED_HINT="   ğŸ’¡ æç¤º: è¾“å…¥ 'eye start' å¼€å¯æŠ¤çœ¼æ¨¡å¼ï¼Œæˆ– 'eye now' è¿›è¡Œå•æ¬¡æ”¾æ¾ã€‚"
        MSG_STATUS_CONFIG="âš™ï¸  é…ç½®: %s é—´éš” / %s è¿œçœº"
        MSG_STATUS_LAST_REST="â±ï¸  ä¸Šæ¬¡ä¼‘æ¯: %s å‰"
        MSG_STATUS_LAST_REST_FROZEN="â±ï¸  ä¸Šæ¬¡ä¼‘æ¯: %s å‰ (å·²å†»ç»“)"
        MSG_STATUS_SOUND="ğŸ”Š éŸ³æ•ˆ: [%s] -> [%s] (å¼€å…³: %s)"
        MSG_STATUS_LANG="ğŸŒ è¯­è¨€: %s"
        MSG_STATUS_SYSTEMD_ACTIVE="Systemd: å·²æ¿€æ´»"
        MSG_SET_USAGE_HINT="ç”¨æ³•: eye set <é—´éš”> <æ—¶é•¿>\nç¤ºä¾‹: eye set 20m 20s"
        MSG_SET_UPDATED="âœ… é…ç½®å·²æ›´æ–°: é—´éš” %s, è¿œçœº %s"
        MSG_LANG_UPDATED="âœ… è¯­è¨€å·²åˆ‡æ¢ä¸º: %s (Language switched to: %s)"
        MSG_LANG_INVALID="âŒ æ— æ•ˆçš„è¯­è¨€é€‰é¡¹ã€‚è¯·ä½¿ç”¨ 'English' æˆ– 'Chinese'."
        MSG_AUTOSTART_ON="âœ… å·²å¼€å¯å¼€æœºè‡ªå¯ (å·²åˆ›å»ºå¹¶å¯ç”¨ systemd æœåŠ¡)"
        MSG_AUTOSTART_OFF="ğŸ›‘ å·²å…³é—­å¼€æœºè‡ªå¯"
        MSG_AUTOSTART_ERROR="âŒ è®¾ç½®å¼€æœºè‡ªå¯å¤±è´¥"
        
        MSG_SOUND_LIST_HEADER="ğŸµ å¯ç”¨éŸ³æ•ˆåˆ—è¡¨ï¼š"
        MSG_SOUND_LIST_BUILTIN="  [å†…ç½®] (ä¸å¯åˆ é™¤)"
        MSG_SOUND_LIST_CUSTOM="  [è‡ªå®šä¹‰]"
        MSG_SOUND_LIST_NONE="  (æ— )"
        MSG_SOUND_LIST_ITEM_NONE="  - none      : é™éŸ³"
        MSG_SOUND_LIST_ITEM_DEFAULT="  - default   : æ ‡å‡†é€šçŸ¥"
        MSG_SOUND_LIST_ITEM_BELL="  - bell      : æ¸…è„†é“ƒå£°"
        MSG_SOUND_LIST_ITEM_COMPLETE="  - complete  : ä»»åŠ¡å®Œæˆ"
        MSG_SOUND_LIST_ITEM_SUCCESS="  - success   : æˆåŠŸéŸ³"
        MSG_SOUND_LIST_ITEM_ALARM="  - alarm     : é—¹é’Ÿ"
        MSG_SOUND_LIST_ITEM_CAMERA="  - camera    : å¿«é—¨å£°"
        MSG_SOUND_LIST_ITEM_DEVICE="  - device    : è®¾å¤‡æ¥å…¥"
        MSG_SOUND_LIST_ITEM_ATTENTION="  - attention : æç¤ºéŸ³"
        
        MSG_SOUND_PLAY_TAG_REQUIRED="âŒ è¯·æŒ‡å®šæ ‡ç­¾"
        MSG_SOUND_PLAY_PLAYING="â–¶ï¸  è¯•å¬ [%s] : %s"
        MSG_SOUND_PLAY_MUTE="ğŸ”‡ (é™éŸ³)"
        MSG_SOUND_PLAY_ERROR="âŒ æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•æ’­æ”¾"
        MSG_SOUND_SET_UPDATED="âœ… éŸ³æ•ˆå·²æ›´æ–°: å¼€å§‹[%s] -> ç»“æŸ[%s]"
        MSG_SOUND_ADD_USAGE="âŒ ç”¨æ³•: eye sound add <tag> <path>"
        MSG_SOUND_ADD_ERROR_BUILTIN="âŒ é”™è¯¯: '%s' æ˜¯å†…ç½®éŸ³æ•ˆï¼Œæ— æ³•è¦†ç›–ã€‚"
        MSG_SOUND_ADD_ERROR_FILE="âŒ é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨: %s"
        MSG_SOUND_ADD_CONFIRM_REPLACE="âš ï¸  æ ‡ç­¾ '%s' å·²å­˜åœ¨ï¼Œæ˜¯å¦æ›¿æ¢ï¼Ÿ[y/N] "
        MSG_SOUND_ADD_ADDED="âœ… å·²æ·»åŠ : %s"
        MSG_SOUND_RM_USAGE="âŒ ç”¨æ³•: eye sound rm <tag>"
        MSG_SOUND_RM_ERROR_BUILTIN="âŒ é”™è¯¯: '%s' æ˜¯å†…ç½®éŸ³æ•ˆï¼Œä¸èƒ½åˆ é™¤ã€‚"
        MSG_SOUND_RM_DELETED="ğŸ—‘ï¸  å·²åˆ é™¤éŸ³æ•ˆ: %s"
        MSG_SOUND_RM_NOT_FOUND="âš ï¸  æœªæ‰¾åˆ°è‡ªå®šä¹‰æ ‡ç­¾: %s"
        MSG_SOUND_RM_NO_CUSTOM="âš ï¸  æš‚æ— è‡ªå®šä¹‰é…ç½®"
        MSG_SOUND_ON="ğŸ”Š å£°éŸ³å·²å¼€å¯"
        MSG_SOUND_OFF="ğŸ”‡ å£°éŸ³å·²å…³é—­"
        MSG_SOUND_USAGE="ç”¨æ³•: eye sound [list|play|set|add|rm|on|off]"
        
        MSG_NOTIFY_TITLE_START="ğŸ‘€ æŠ¤çœ¼æ—¶é—´"
        MSG_NOTIFY_BODY_START="å¼€å§‹è¿œçœº %sï¼"
        MSG_NOTIFY_TITLE_END="âœ… è¿œçœºç»“æŸ"
        MSG_NOTIFY_BODY_END="çœ¼ç›ä¼‘æ¯å¥½äº†ï¼Œç»§ç»­åŠ æ²¹å§ï¼"
        MSG_ERROR_INVALID_TIME_FORMAT="é”™è¯¯: æ— æ•ˆçš„æ—¶é—´æ ¼å¼"
        
    else
        # English
        MSG_USAGE_HEADER="Usage: eye <command> [args]"
        MSG_USAGE_CORE="Core Commands:"
        MSG_USAGE_CMD_START="  start            Start the eye protection daemon"
        MSG_USAGE_CMD_STOP="  stop             Stop the eye protection daemon (Graceful)"
        MSG_USAGE_CMD_KILL="  kill             Force kill all processes and reset state"
        MSG_USAGE_CMD_PAUSE="  pause <time>     Pause for a specific duration (e.g., 1h, 30m, 1h30m)"
        MSG_USAGE_CMD_RESUME="  resume           Resume from pause immediately"
        MSG_USAGE_CMD_PASS="  pass <time>      Skip waiting time (advance timer)"
        MSG_USAGE_CMD_STATUS="  status           Show current status"
        MSG_USAGE_CMD_NOW="  now [--reset]    Trigger manual break (--reset to reset timer)"
        MSG_USAGE_CMD_SET="  set <gap> <look> Set interval and look-away duration (units: s, m, h)\n                   Example: eye set 20m 20s"
        MSG_USAGE_CMD_LANG="  language <lang>  Set language (English/Chinese)"
        MSG_USAGE_CMD_AUTOSTART="  autostart [on|off] Manage autostart (systemd)"
        MSG_USAGE_AUDIO="Audio Management (eye sound ...):"
        MSG_USAGE_CMD_SOUND_LIST="  sound list              List all available sounds"
        MSG_USAGE_CMD_SOUND_PLAY="  sound play <tag>        Preview a specific sound"
        MSG_USAGE_CMD_SOUND_SET="  sound set <start> <end> Set start and end sounds"
        MSG_USAGE_CMD_SOUND_ADD="  sound add <tag> <path>  Add a custom audio file"
        MSG_USAGE_CMD_SOUND_RM="  sound rm  <tag>         Remove a custom sound"
        MSG_USAGE_CMD_SOUND_SWITCH="  sound on|off            Turn sound on or off globally"
        
        MSG_START_ALREADY_RUNNING="âš ï¸  Eye protection mode is already running (PID: %s)"
        MSG_START_STARTED="âœ… Eye protection mode started"
        MSG_STOP_STOPPED="ğŸ›‘ Stopped"
        MSG_STOP_NOT_RUNNING="âš ï¸  Not running"
        MSG_KILL_DONE="âœ… All eye processes killed and state reset"
        MSG_PAUSE_SPECIFY_DURATION="âŒ Please specify duration (e.g., 1h, 30m)"
        MSG_PAUSE_PAUSED="â¸ï¸  Eye protection paused for %s (until %s)"
        MSG_PAUSE_ERROR_FORMAT="âŒ Invalid format. Example: 1h, 30m, 10s"
        MSG_RESUME_RESUMED="â–¶ï¸  Pause cancelled, resumed"
        MSG_RESUME_NOT_PAUSED="âš ï¸  Not currently paused"
        MSG_PASS_ERROR="âŒ Please specify time (e.g. 10m)"
        MSG_PASS_SKIPPED="â© Skipped %s (Break will come sooner)"
        MSG_PASS_TRIGGERED="âš¡ï¸ Time limit exceeded, triggering break immediately!"
        MSG_NOW_MANUAL_RESET="âœ… Triggered manual break, timer reset."
        MSG_NOW_MANUAL_TRIGGERED="âœ… Manual break triggered."
        MSG_NOW_MANUAL_NO_RESET="ğŸ”” Manual break finished. (Note: Daemon is stopped)"
        MSG_NOW_TRIGGERING="ğŸ”„ Triggering look-away..."
        MSG_STATUS_RUNNING="ğŸŸ¢ Running | PID: %s"
        MSG_STATUS_PAUSED_REMAINING="â¸ï¸  [Paused] Remaining: %s (until %s)"
        MSG_STATUS_STOPPED="ğŸ”´ Service Stopped"
        MSG_STATUS_KILLED="ğŸ”´ Service Not Running"
        MSG_STATUS_STOPPED_HINT="   ğŸ’¡ Hint: Type 'eye start' to enable, or 'eye now' for a manual break."
        MSG_STATUS_CONFIG="âš™ï¸  Config: %s gap / %s look-away"
        MSG_STATUS_LAST_REST="â±ï¸  Last rest: %s ago"
        MSG_STATUS_LAST_REST_FROZEN="â±ï¸  Last rest: %s ago (Frozen)"
        MSG_STATUS_SOUND="ğŸ”Š Sound: [%s] -> [%s] (Switch: %s)"
        MSG_STATUS_LANG="ğŸŒ Language: %s"
        MSG_STATUS_SYSTEMD_ACTIVE="Systemd: Active"
        MSG_SET_USAGE_HINT="Usage: eye set <gap> <look>\nExample: eye set 20m 20s"
        MSG_SET_UPDATED="âœ… Config updated: Gap %s, Look-away %s"
        MSG_LANG_UPDATED="âœ… Language switched to: %s"
        MSG_LANG_INVALID="âŒ Invalid language option. Please use 'English' or 'Chinese'."
        MSG_AUTOSTART_ON="âœ… Autostart enabled (systemd service created and enabled)"
        MSG_AUTOSTART_OFF="ğŸ›‘ Autostart disabled"
        MSG_AUTOSTART_ERROR="âŒ Failed to setup autostart"
        
        MSG_SOUND_LIST_HEADER="ğŸµ Available Sounds:"
        MSG_SOUND_LIST_BUILTIN="  [Built-in] (Cannot be removed)"
        MSG_SOUND_LIST_CUSTOM="  [Custom]"
        MSG_SOUND_LIST_NONE="  (None)"
        MSG_SOUND_LIST_ITEM_NONE="  - none      : Mute"
        MSG_SOUND_LIST_ITEM_DEFAULT="  - default   : Standard message"
        MSG_SOUND_LIST_ITEM_BELL="  - bell      : Bell"
        MSG_SOUND_LIST_ITEM_COMPLETE="  - complete  : Task complete"
        MSG_SOUND_LIST_ITEM_SUCCESS="  - success   : Success"
        MSG_SOUND_LIST_ITEM_ALARM="  - alarm     : Alarm clock"
        MSG_SOUND_LIST_ITEM_CAMERA="  - camera    : Camera shutter"
        MSG_SOUND_LIST_ITEM_DEVICE="  - device    : Device added"
        MSG_SOUND_LIST_ITEM_ATTENTION="  - attention : Attention"
        
        MSG_SOUND_PLAY_TAG_REQUIRED="âŒ Please specify a tag"
        MSG_SOUND_PLAY_PLAYING="â–¶ï¸  Previewing [%s] : %s"
        MSG_SOUND_PLAY_MUTE="ğŸ”‡ (Muted)"
        MSG_SOUND_PLAY_ERROR="âŒ File not found or cannot play"
        MSG_SOUND_SET_UPDATED="âœ… Sounds updated: Start[%s] -> End[%s]"
        MSG_SOUND_ADD_USAGE="âŒ Usage: eye sound add <tag> <path>"
        MSG_SOUND_ADD_ERROR_BUILTIN="âŒ Error: '%s' is a built-in sound, cannot overwrite."
        MSG_SOUND_ADD_ERROR_FILE="âŒ Error: File not found: %s"
        MSG_SOUND_ADD_CONFIRM_REPLACE="âš ï¸  Tag '%s' already exists, replace? [y/N] "
        MSG_SOUND_ADD_ADDED="âœ… Added: %s"
        MSG_SOUND_RM_USAGE="âŒ Usage: eye sound rm <tag>"
        MSG_SOUND_RM_ERROR_BUILTIN="âŒ Error: '%s' is a built-in sound, cannot remove."
        MSG_SOUND_RM_DELETED="ğŸ—‘ï¸  Deleted sound: %s"
        MSG_SOUND_RM_NOT_FOUND="âš ï¸  Custom tag not found: %s"
        MSG_SOUND_RM_NO_CUSTOM="âš ï¸  No custom configuration"
        MSG_SOUND_ON="ğŸ”Š Sound enabled"
        MSG_SOUND_OFF="ğŸ”‡ Sound disabled"
        MSG_SOUND_USAGE="Usage: eye sound [list|play|set|add|rm|on|off]"
        
        MSG_NOTIFY_TITLE_START="ğŸ‘€ Eye Protection"
        MSG_NOTIFY_BODY_START="Look away for %s!"
        MSG_NOTIFY_TITLE_END="âœ… Break Ended"
        MSG_NOTIFY_BODY_END="Eyes rested. Keep going!"
        MSG_ERROR_INVALID_TIME_FORMAT="Error: Invalid time format"
    fi
}

# =================æ ¸å¿ƒåŠŸèƒ½å‡½æ•°=================

# æ—¶é—´è§£æå‡½æ•° (æ”¯æŒ 1h 30m 20s æ ¼å¼)
_parse_duration() {
    local input="$*"
    # ç§»é™¤æ‰€æœ‰ç©ºæ ¼
    input="${input// /}"
    
    # å¦‚æœæ˜¯çº¯æ•°å­—ï¼Œé»˜è®¤ä¸ºç§’
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
        return
    fi

    local total_seconds=0
    
    # æå–å¤© (d)
    if [[ "$input" =~ ([0-9]+)d ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]} * 86400))
    fi
    # æå–å°æ—¶ (h)
    if [[ "$input" =~ ([0-9]+)h ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]} * 3600))
    fi
    # æå–åˆ†é’Ÿ (m)
    if [[ "$input" =~ ([0-9]+)m ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]} * 60))
    fi
    # æå–ç§’ (s)
    if [[ "$input" =~ ([0-9]+)s ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]}))
    fi

    if [ "$total_seconds" -eq 0 ]; then
        echo "$MSG_ERROR_INVALID_TIME_FORMAT" >&2
        return 1
    fi
    
    echo "$total_seconds"
}

# æ ¼å¼åŒ–ç§’æ•°ä¸ºæ˜“è¯»æ ¼å¼
_format_duration() {
    local T=$1
    local D=$((T/60/60/24))
    local H=$((T/60/60%24))
    local M=$((T/60%60))
    local S=$((T%60))
    
    [[ $D -gt 0 ]] && printf '%dd ' $D
    [[ $H -gt 0 ]] && printf '%dh ' $H
    [[ $M -gt 0 ]] && printf '%dm ' $M
    [[ $D -eq 0 && $H -eq 0 && $M -eq 0 ]] && printf '%ds' $S || printf '%ds' $S
}

# åŠ è½½é…ç½®
_load_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<EOF
REST_GAP=$DEFAULT_REST_GAP
LOOK_AWAY=$DEFAULT_LOOK_AWAY
SOUND_START=$DEFAULT_SOUND_START
SOUND_END=$DEFAULT_SOUND_END
SOUND_SWITCH=$DEFAULT_SOUND_SWITCH
LANGUAGE=$DEFAULT_LANGUAGE
EOF
    fi
    source "$CONFIG_FILE"
    
    # ç¡®ä¿å˜é‡æœ‰é»˜è®¤å€¼
    REST_GAP=${REST_GAP:-$DEFAULT_REST_GAP}
    LOOK_AWAY=${LOOK_AWAY:-$DEFAULT_LOOK_AWAY}
    SOUND_START=${SOUND_START:-$DEFAULT_SOUND_START}
    SOUND_END=${SOUND_END:-$DEFAULT_SOUND_END}
    SOUND_SWITCH=${SOUND_SWITCH:-$DEFAULT_SOUND_SWITCH}
    LANGUAGE=${LANGUAGE:-$DEFAULT_LANGUAGE}

    [ -f "$CUSTOM_SOUNDS_MAP" ] && source "$CUSTOM_SOUNDS_MAP"
}

# ä¿å­˜åŸºç¡€é…ç½®
_save_config() {
    cat > "$CONFIG_FILE" <<EOF
REST_GAP=${REST_GAP:-$DEFAULT_REST_GAP}
LOOK_AWAY=${LOOK_AWAY:-$DEFAULT_LOOK_AWAY}
SOUND_START=${SOUND_START:-$DEFAULT_SOUND_START}
SOUND_END=${SOUND_END:-$DEFAULT_SOUND_END}
SOUND_SWITCH=${SOUND_SWITCH:-$DEFAULT_SOUND_SWITCH}
LANGUAGE=${LANGUAGE:-$DEFAULT_LANGUAGE}
EOF
}

# è·å–éŸ³æ•ˆè·¯å¾„
_get_sound_path() {
    local tag=$1
    local path=""
    
    case "$tag" in
        "none")      echo "NONE"; return ;; 
        "default")   path="/usr/share/sounds/freedesktop/stereo/message.oga" ;; 
        "bell")      path="/usr/share/sounds/freedesktop/stereo/bell.oga" ;; 
        "complete")  path="/usr/share/sounds/freedesktop/stereo/complete.oga" ;; 
        "success")   path="/usr/share/sounds/freedesktop/stereo/service-login.oga" ;; 
        "alarm")     path="/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga" ;; 
        "camera")    path="/usr/share/sounds/freedesktop/stereo/camera-shutter.oga" ;; 
        "device")    path="/usr/share/sounds/freedesktop/stereo/device-added.oga" ;; 
        "attention") path="/usr/share/sounds/freedesktop/stereo/window-attention.oga" ;; 
        *)
            local custom_var="SOUND_PATH_${tag}"
            path="${!custom_var}" 
            ;; 
    esac

    if [ ! -f "$path" ]; then
         path="/usr/share/sounds/freedesktop/stereo/message.oga"
    fi
    echo "$path"
}

_play() {
    [ "$SOUND_SWITCH" != "on" ] && return
    local tag=$1
    local file=$(_get_sound_path "$tag")
    
    if [ "$file" == "NONE" ]; then
        return
    elif [ -f "$file" ] && command -v paplay > /dev/null; then
        paplay "$file" > /dev/null 2>&1 &
    fi
}

_eye_action() {
    local reset_timer=${1:-true}
    _load_config
    _init_messages
    
    local look_fmt=$(_format_duration ${LOOK_AWAY})
    local body_start=$(printf "$MSG_NOTIFY_BODY_START" "$look_fmt")
    
    notify-send -i appointment-soon -t 5000 "$MSG_NOTIFY_TITLE_START" "$body_start"
    _play "$SOUND_START"
    
    sleep "$LOOK_AWAY"
    
    notify-send -i emblem-success -t 3000 "$MSG_NOTIFY_TITLE_END" "$MSG_NOTIFY_BODY_END"
    _play "$SOUND_END"
    
    if [ "$reset_timer" == "true" ]; then
        date +%s > "$EYE_LOG"
    fi
}

# å®ˆæŠ¤è¿›ç¨‹ä¸»å¾ªç¯
IS_ACTING=0
_check_trigger() {
    # å¦‚æœæ­£åœ¨æ‰§è¡ŒåŠ¨ä½œï¼Œåˆ™å¿½ç•¥
    [ "$IS_ACTING" -eq 1 ] && return
    
    _load_config
    # _init_messages # Loop already calls it? Maybe better here too
    
    local current_time=$(date +%s)
    
    # Pause check
    if [ -f "$PAUSE_FILE" ]; then
        pause_until=$(cat "$PAUSE_FILE")
        if [ "$current_time" -lt "$pause_until" ]; then
             return
        else
             rm "$PAUSE_FILE" 
             # Resume logic: add paused duration
             if [ -f "$PAUSE_START_FILE" ]; then
                 start_pause=$(cat "$PAUSE_START_FILE")
                 duration=$((current_time - start_pause))
                 old_last=$(cat "$EYE_LOG" 2>/dev/null || echo $current_time)
                 new_last=$((old_last + duration))
                 echo "$new_last" > "$EYE_LOG"
                 rm "$PAUSE_START_FILE"
             fi
        fi
    fi

    local last_time=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
    if [ $((current_time - last_time)) -ge $REST_GAP ]; then
         IS_ACTING=1
         _eye_action true # Run in foreground of this function/subshell
         IS_ACTING=0
    fi
}

_daemon_loop() {
    echo $BASHPID > "$PID_FILE"
    
    # Handle Stop Resume
    if [ -f "$STOP_FILE" ]; then
        stop_time=$(cat "$STOP_FILE")
        current_time=$(date +%s)
        stopped_duration=$((current_time - stop_time))
        old_last=$(cat "$EYE_LOG" 2>/dev/null || echo $current_time)
        new_last=$((old_last + stopped_duration))
        echo "$new_last" > "$EYE_LOG"
        rm "$STOP_FILE"
    fi
    
    if [ ! -f "$EYE_LOG" ]; then
        date +%s > "$EYE_LOG"
    fi
    
    # æ³¨å†Œä¿¡å·å¤„ç†
    trap '_check_trigger' SIGUSR1
    
    while true; do
        _check_trigger
        
        # ä½¿ç”¨ sleep & wait å®ç°å¯ä¸­æ–­çš„ sleep
        sleep 5 &
        wait $!
    done
}

# =================å‘½ä»¤å¤„ç†é€»è¾‘=================

_usage() {
    echo "$MSG_USAGE_HEADER"
    echo ""
    echo "$MSG_USAGE_CORE"
    echo "$MSG_USAGE_CMD_START"
    echo "$MSG_USAGE_CMD_STOP"
    echo "$MSG_USAGE_CMD_KILL"
    echo "$MSG_USAGE_CMD_PAUSE"
    echo "$MSG_USAGE_CMD_RESUME"
    echo "$MSG_USAGE_CMD_PASS"
    echo "$MSG_USAGE_CMD_STATUS"
    echo "$MSG_USAGE_CMD_NOW"
    echo -e "$MSG_USAGE_CMD_SET"
    echo "$MSG_USAGE_CMD_LANG"
    echo "$MSG_USAGE_CMD_AUTOSTART"
    echo ""
    echo "$MSG_USAGE_AUDIO"
    echo "$MSG_USAGE_CMD_SOUND_LIST"
    echo "$MSG_USAGE_CMD_SOUND_PLAY"
    echo "$MSG_USAGE_CMD_SOUND_SET"
    echo "$MSG_USAGE_CMD_SOUND_ADD"
    echo "$MSG_USAGE_CMD_SOUND_RM"
    echo "$MSG_USAGE_CMD_SOUND_SWITCH"
}

_cmd_autostart() {
    local action=$1
    if [[ "$action" == "on" ]]; then
        mkdir -p "$SYSTEMD_DIR"
        
        local install_path="${HOME}/.local/bin/eye"
        if [ ! -x "$install_path" ]; then
             install_path=$(readlink -f "$0")
        fi

        cat > "$SERVICE_FILE" <<EOF
[Unit]
Description=Eye Protection Tool
After=graphical-session.target

[Service]
Type=simple
ExecStart=$install_path daemon
Restart=always
RestartSec=10

[Install]
WantedBy=default.target
EOF
        
        systemctl --user daemon-reload
        systemctl --user enable eye.service >/dev/null 2>&1
        systemctl --user start eye.service >/dev/null 2>&1
        
        if [ $? -eq 0 ]; then
            echo "$MSG_AUTOSTART_ON"
        else
            echo "$MSG_AUTOSTART_ERROR"
        fi
        
    elif [[ "$action" == "off" ]]; then
        systemctl --user stop eye.service >/dev/null 2>&1
        systemctl --user disable eye.service >/dev/null 2>&1
        rm -f "$SERVICE_FILE"
        systemctl --user daemon-reload
        echo "$MSG_AUTOSTART_OFF"
    else
        echo "Usage: eye autostart [on|off]"
    fi
}

_cmd_sound() {
    local subcmd=$1
    shift
    _load_config

    case "$subcmd" in
        list)
            echo "$MSG_SOUND_LIST_HEADER"
            echo "$MSG_SOUND_LIST_BUILTIN"
            echo "$MSG_SOUND_LIST_ITEM_NONE"
            echo "$MSG_SOUND_LIST_ITEM_DEFAULT"
            echo "$MSG_SOUND_LIST_ITEM_BELL"
            echo "$MSG_SOUND_LIST_ITEM_COMPLETE"
            echo "$MSG_SOUND_LIST_ITEM_SUCCESS"
            echo "$MSG_SOUND_LIST_ITEM_ALARM"
            echo "$MSG_SOUND_LIST_ITEM_CAMERA"
            echo "$MSG_SOUND_LIST_ITEM_DEVICE"
            echo "$MSG_SOUND_LIST_ITEM_ATTENTION"
            
            echo ""
            echo "$MSG_SOUND_LIST_CUSTOM"
            local has_custom=0
            if [ -f "$CUSTOM_SOUNDS_MAP" ]; then
                while IFS='=' read -r key value; do
                    if [[ $key == SOUND_PATH_* ]]; then
                        tag=${key#SOUND_PATH_}
                        echo "  - $tag : $value"
                        has_custom=1
                    fi
                done < "$CUSTOM_SOUNDS_MAP"
            fi
            [ $has_custom -eq 0 ] && echo "$MSG_SOUND_LIST_NONE"
            ;; 
        play)
            local tag=$1
            [ -z "$tag" ] && { echo "$MSG_SOUND_PLAY_TAG_REQUIRED"; return 1; }
            local path=$(_get_sound_path "$tag")
            printf "$MSG_SOUND_PLAY_PLAYING\n" "$tag" "$path"
            if [ -f "$path" ]; then
                command -v paplay >/dev/null && paplay "$path"
            elif [ "$tag" == "none" ]; then
                echo "$MSG_SOUND_PLAY_MUTE"
            else
                echo "$MSG_SOUND_PLAY_ERROR"
            fi
            ;; 
        set)
            local s1=${1:-$SOUND_START}
            local s2=${2:-$SOUND_END}
            SOUND_START=$s1
            SOUND_END=$s2
            _save_config
            printf "$MSG_SOUND_SET_UPDATED\n" "$s1" "$s2"
            ;; 
        add)
            local tag=$1
            local path=$2
            if [ -z "$tag" ] || [ -z "$path" ]; then
                echo "$MSG_SOUND_ADD_USAGE"
                return 1
            fi
            if [[ " none default bell complete success alarm camera device attention " =~ " $tag " ]]; then
                 printf "$MSG_SOUND_ADD_ERROR_BUILTIN\n" "$tag"
                 return 1
            fi
            if [ ! -f "$path" ]; then
                printf "$MSG_SOUND_ADD_ERROR_FILE\n" "$path"
                return 1
            fi
            if grep -q "SOUND_PATH_${tag}=" "$CUSTOM_SOUNDS_MAP" 2>/dev/null; then
                printf "$MSG_SOUND_ADD_CONFIRM_REPLACE" "$tag"
                read choice
                [[ "$choice" != "y" && "$choice" != "Y" ]] && return
            fi
            local abs_path=$(readlink -f "$path")
            [ -f "$CUSTOM_SOUNDS_MAP" ] && sed -i "/SOUND_PATH_${tag}=/d" "$CUSTOM_SOUNDS_MAP"
            echo "SOUND_PATH_${tag}=\"${abs_path}\"" >> "$CUSTOM_SOUNDS_MAP"
            printf "$MSG_SOUND_ADD_ADDED\n" "$tag"
            ;; 
        rm)
            local tag=$1
            if [ -z "$tag" ]; then
                echo "$MSG_SOUND_RM_USAGE"
                return 1
            fi
            if [[ " none default bell complete success alarm camera device attention " =~ " $tag " ]]; then
                 printf "$MSG_SOUND_RM_ERROR_BUILTIN\n" "$tag"
                 return 1
            fi
            if [ -f "$CUSTOM_SOUNDS_MAP" ]; then
                if grep -q "SOUND_PATH_${tag}=" "$CUSTOM_SOUNDS_MAP"; then
                    sed -i "/SOUND_PATH_${tag}=/d" "$CUSTOM_SOUNDS_MAP"
                    printf "$MSG_SOUND_RM_DELETED\n" "$tag"
                else
                    printf "$MSG_SOUND_RM_NOT_FOUND\n" "$tag"
                fi
            else
                echo "$MSG_SOUND_RM_NO_CUSTOM"
            fi
            ;; 
        on)
            SOUND_SWITCH="on"; _save_config; echo "$MSG_SOUND_ON" ;; 
        off)
            SOUND_SWITCH="off"; _save_config; echo "$MSG_SOUND_OFF" ;; 
        *)
            echo "$MSG_SOUND_USAGE" ;; 
    esac
}
# =================ä¸»ç¨‹åºå…¥å£=================

_load_config
_init_messages

# å¤„ç† --help
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]] || [[ -z "$1" ]]; then
    _usage
    exit 0
fi

case "$1" in
    start)
        if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null;
        then
            printf "$MSG_START_ALREADY_RUNNING\n" "$(cat "$PID_FILE")"
        else
            ( _daemon_loop ) > /dev/null 2>&1 &
            disown
            echo "$MSG_START_STARTED"
        fi
        ;; 
    stop)
        if systemctl --user is-active --quiet eye.service 2>/dev/null;
        then
            systemctl --user stop eye.service
        fi
        
        if [ -f "$PID_FILE" ]; then
            pkill -P $(cat "$PID_FILE") >/dev/null 2>&1
            kill $(cat "$PID_FILE") >/dev/null 2>&1
            rm "$PID_FILE" 2>/dev/null
            rm "$PAUSE_FILE" 2>/dev/null
            
            # Save Stop Time
            date +%s > "$STOP_FILE"
            
            echo "$MSG_STOP_STOPPED"
        else
            echo "$MSG_STOP_STOPPED"
        fi
        ;; 
    kill)
        _cmd_autostart "off" >/dev/null 2>&1
        systemctl --user stop eye.service 2>/dev/null
        
        if [ -f "$PID_FILE" ]; then
            pid=$(cat "$PID_FILE")
            kill "$pid" 2>/dev/null
            kill -9 "$pid" 2>/dev/null
            rm "$PID_FILE" 2>/dev/null
        fi
        
        for pid in $(pgrep -f "bin/eye"); do
            if [ "$pid" != "$$" ] && [ "$pid" != "$BASHPID" ]; then
                kill -9 "$pid" 2>/dev/null
            fi
        done
        
        rm "$PAUSE_FILE" 2>/dev/null
        rm "$EYE_LOG" 2>/dev/null
        rm "$STOP_FILE" 2>/dev/null
        rm "$PAUSE_START_FILE" 2>/dev/null
        
        echo "$MSG_KILL_DONE"
        ;;
    daemon)
        _daemon_loop
        ;; 
    pause)
        duration_str="$*"
        [ -z "$duration_str" ] && { echo "$MSG_PAUSE_SPECIFY_DURATION"; exit 1; }
        seconds=$(_parse_duration "$duration_str")
        if [ $? -eq 0 ]; then
            target_time=$(( $(date +%s) + seconds ))
            echo "$target_time" > "$PAUSE_FILE"
            date +%s > "$PAUSE_START_FILE"
            formatted_dur=$(_format_duration "$seconds")
            target_date=$(date -d "@$target_time" "+%H:%M:%S")
            printf "$MSG_PAUSE_PAUSED\n" "$formatted_dur" "$target_date"
        else
             echo "$MSG_PAUSE_ERROR_FORMAT"
        fi
        ;;
    pass)
        duration_str="$*"
        [ -z "$duration_str" ] && { echo "$MSG_PASS_ERROR"; exit 1; }
        seconds=$(_parse_duration "$duration_str")
        if [ $? -eq 0 ]; then
            if [ ! -f "$EYE_LOG" ]; then
                 date +%s > "$EYE_LOG"
            fi
            
            # 1. æ›´æ–°æ—¥å¿—
            current_last=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
            new_last=$((current_last - seconds))
            echo "$new_last" > "$EYE_LOG"
            
            # 2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³è§¦å‘
            current_time=$(date +%s)
            diff=$((current_time - new_last))
            
            if [ $diff -ge $REST_GAP ]; then
                echo "$MSG_PASS_TRIGGERED"
                # å¦‚æœ daemon åœ¨è¿è¡Œï¼Œå‘é€ä¿¡å·è®©å…¶ç«‹å³å¤„ç†
                if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null;
                then
                    kill -SIGUSR1 $(cat "$PID_FILE")
                fi
            else
                printf "$MSG_PASS_SKIPPED\n" "$(_format_duration $seconds)"
            fi
        else
             echo "$MSG_PAUSE_ERROR_FORMAT"
        fi
        ;;
    resume)
        if [ -f "$PAUSE_FILE" ]; then
            # resume command logic to adjust log
            if [ -f "$PAUSE_START_FILE" ]; then
                 start_pause=$(cat "$PAUSE_START_FILE")
                 current_time=$(date +%s)
                 duration=$((current_time - start_pause))
                 old_last=$(cat "$EYE_LOG" 2>/dev/null || echo $current_time)
                 new_last=$((old_last + duration))
                 echo "$new_last" > "$EYE_LOG"
                 rm "$PAUSE_START_FILE"
            fi
            rm "$PAUSE_FILE"
            echo "$MSG_RESUME_RESUMED"
        else
            echo "$MSG_RESUME_NOT_PAUSED"
        fi
        ;; 
    now)
        echo "$MSG_NOW_TRIGGERING"
        
        is_reset="false"
        if [[ "$2" == "--reset" ]]; then
            is_reset="true"
        fi
        
        ( _eye_action "$is_reset" ) > /dev/null 2>&1 &
        disown
        
        if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null;
        then
            if [[ "$is_reset" == "true" ]]; then
                echo "$MSG_NOW_MANUAL_RESET"
            else
                echo "$MSG_NOW_MANUAL_TRIGGERED"
            fi
        else
            echo "$MSG_NOW_MANUAL_NO_RESET"
        fi
        ;; 
    status)
        is_running=0
        if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null;
        then
            is_running=1
        fi
        
        # Case 1: Running
        if [ $is_running -eq 1 ]; then
            _load_config
            printf "$MSG_STATUS_RUNNING\n" "$(cat "$PID_FILE")"
            
            if systemctl --user is-active --quiet eye.service 2>/dev/null;
            then
                echo "$MSG_STATUS_SYSTEMD_ACTIVE"
            fi
            
            if [ -f "$PAUSE_FILE" ]; then
                pause_until=$(cat "$PAUSE_FILE")
                current=$(date +%s)
                if [ "$current" -lt "$pause_until" ]; then
                    remaining=$((pause_until - current))
                    target_date=$(date -d "@$pause_until" "+%H:%M:%S")
                    printf "$MSG_STATUS_PAUSED_REMAINING\n" "$(_format_duration $remaining)" "$target_date"
                    
                    # Frozen Diff for Pause
                    if [ -f "$PAUSE_START_FILE" ]; then
                        pause_start=$(cat "$PAUSE_START_FILE")
                        last=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
                        diff=$((pause_start - last))
                        printf "$MSG_STATUS_LAST_REST_FROZEN\n" "$(_format_duration $diff)"
                    fi
                else
                    rm "$PAUSE_FILE"
                fi
            else 
                # Normal running
                last=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
                diff=$(( $(date +%s) - last ))
                gap_fmt=$(_format_duration $REST_GAP)
                look_fmt=$(_format_duration $LOOK_AWAY)
                printf "$MSG_STATUS_CONFIG\n" "$gap_fmt" "$look_fmt"
                printf "$MSG_STATUS_LAST_REST\n" "$(_format_duration $diff)"
                printf "$MSG_STATUS_SOUND\n" "$SOUND_START" "$SOUND_END" "$SOUND_SWITCH"
                printf "$MSG_STATUS_LANG\n" "$LANGUAGE"
            fi
            
        # Case 2: Stopped (Log exists but PID dead)
        elif [ -f "$EYE_LOG" ]; then
            _load_config
            echo "$MSG_STATUS_STOPPED"
            
            gap_fmt=$(_format_duration $REST_GAP)
            look_fmt=$(_format_duration $LOOK_AWAY)
            printf "$MSG_STATUS_CONFIG\n" "$gap_fmt" "$look_fmt"
            
            # Frozen diff for Stop
            if [ -f "$STOP_FILE" ]; then
                stop_time=$(cat "$STOP_FILE")
                last=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
                diff=$((stop_time - last))
                printf "$MSG_STATUS_LAST_REST_FROZEN\n" "$(_format_duration $diff)"
            else
                # Fallback if no stop time recorded (legacy stop)
                last=$(cat "$EYE_LOG" 2>/dev/null || date +%s)
                diff=$(( $(date +%s) - last ))
                printf "$MSG_STATUS_LAST_REST\n" "$(_format_duration $diff)"
            fi
            
            printf "$MSG_STATUS_SOUND\n" "$SOUND_START" "$SOUND_END" "$SOUND_SWITCH"
            echo "$MSG_STATUS_STOPPED_HINT"
            
        # Case 3: Killed/Fresh (No Log, No PID)
        else
            echo "$MSG_STATUS_KILLED"
            echo "$MSG_STATUS_STOPPED_HINT"
        fi
        ;; 
    set)
        if [ -z "$2" ]; then
            echo -e "$MSG_SET_USAGE_HINT"
            exit 1
        fi
        
        gap_input=$2
        look_input=$3
        
        _load_config
        
        new_gap=$(_parse_duration "$gap_input")
        [ $? -ne 0 ] && exit 1
        
        if [ -n "$look_input" ]; then
            new_look=$(_parse_duration "$look_input")
            [ $? -ne 0 ] && exit 1
        else
            new_look=$LOOK_AWAY
        fi
        
        REST_GAP=$new_gap
        LOOK_AWAY=$new_look
        _save_config
        
        printf "$MSG_SET_UPDATED\n" "$(_format_duration $REST_GAP)" "$(_format_duration $LOOK_AWAY)"
        ;; 
    language)
        lang_input=$2
        if [[ "$lang_input" == "en" ]] || [[ "$lang_input" == "English" ]]; then
            LANGUAGE="en"
        elif [[ "$lang_input" == "zh" ]] || [[ "$lang_input" == "Chinese" ]]; then
            LANGUAGE="zh"
        else
            echo "$MSG_LANG_INVALID"
            exit 1
        fi
        _save_config
        _init_messages
        printf "$MSG_LANG_UPDATED\n" "$LANGUAGE" "$LANGUAGE"
        ;; 
    autostart)
        _cmd_autostart "$2"
        ;; 
    sound)
        shift
        _cmd_sound "$@"
        ;; 
    _action)
        _eye_action
        ;; 
    *)
        _usage
        ;; 
esac
